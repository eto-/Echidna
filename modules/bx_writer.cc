/* BOREXINO Reconstruction program
 *
 * Author: Davide D'Angelo <davide.dangelo@mi.infn.it>
 * based on previous work by Razeto&Pallavicini
 * Maintainer: Davide D'Angelo <davide.dangelo@mi.infn.it>
 *
 * $Id: bx_writer.cc,v 1.46 2015/04/23 22:38:17 misiaszek Exp $
 *
 * Implementation of bx_writer
 *
 */
#include "constants.hh"
#include "bx_writer.hh"
#include "BxEvent.hh"
#include "bx_dbi.hh"
#include "bx_echidna_event.hh"
#include "barn_interface.hh"

#include <TFile.h>
#include <TNetFile.h>
#include <TTree.h>
#include <iostream>
#include <sstream>
#include <iomanip>
#include <signal.h>
#include <string.h>
#include <unistd.h>

static char* __remove_file = 0;
void remove_file (int32_t unused) {
  if (__remove_file && ::strlen (__remove_file)) ::unlink (__remove_file);
  signal (SIGTERM, SIG_DFL);
  kill (getpid (), SIGTERM);
}

// ctor
bx_writer::bx_writer (): bx_base_module("bx_writer", bx_base_module::writer), u4_written_events(0) {
}

// module interface
void bx_writer::begin () {
  // get parameters: 0.directory
  std::string directory = ".";
  if (check_parameter ("directory"))
    directory = get_parameter ("directory").get_string ();

  // get parameters: 1.file name
  std::string file_name = "auto";
  if (check_parameter ("file_name")) 
    file_name = get_parameter ("file_name").get_string ();
  if(file_name == "auto") {
    std::ostringstream fn_stream;
    std::string config_name = get_configuration_name();
    if (config_name == "default")
      fn_stream << "Run" << std::setw(6) << std::setfill('0') << bx_dbi::get()->get_current_run_number() << "_c" << CYCLE_NUMBER << ".root";
    else
      fn_stream << "Run" << std::setw(6) << std::setfill('0') << bx_dbi::get()->get_current_run_number() 
		<< "_" << config_name << "_c" << CYCLE_NUMBER << ".root";     
    file_name = fn_stream.str();
  }

  file_name = directory+"/"+file_name;

  // get parameters: 2.overwrite
  bool overwrite = false;
  if (check_parameter ("file_overwrite")) 
    overwrite = get_parameter ("file_overwrite").get_int ();

  // open root file
  char open_mode[100];
  sprintf(open_mode, overwrite ? "RECREATE" : "CREATE");
  if (file_name.find ("://") == std::string::npos) {
    p_root_file = new TFile (file_name.c_str (), open_mode);
    __remove_file = ::strdup (file_name.c_str ()); 
    signal (SIGTERM, remove_file);
  } else 
    p_root_file = new TNetFile (file_name.c_str (), open_mode);

  if (p_root_file->IsZombie ()) 
    get_message (bx_message::critic) << "failed to open root file " 
    	<< file_name << ". File probably exists." << dispatch;
  else
    get_message (bx_message::info) << "root file " << file_name 
    	<< " successfully opened" << dispatch;

  if (check_parameter ("write_tree") && get_parameter ("write_tree").get_bool ()) {

    // get parameters: 3.buffer_size
    int32_t buffer_size = 32000;
    if (check_parameter ("buffer_size"))
      buffer_size = get_parameter ("buffer_size").get_int();

    // get parameters: 4.splitting_level
    int32_t splitting_level = 99;
    if (check_parameter ("splitting_level"))
      splitting_level = get_parameter ("splitting_level").get_int();

    bx_write_opts opts;
    m_parse_options(opts);

    // create BxEvent
    p_root_event = new BxEvent(opts);
    // create and branch TTree
    p_root_tree = new TTree ("bxtree", "Borexino Events Tree (generated by echidna)");
    Long64_t tree_size = 0x2000000000ULL; // 128GB
    p_root_tree->SetMaxTreeSize(tree_size);
    p_root_tree->Branch ("events", "BxEvent", &p_root_event, buffer_size, splitting_level);
    get_message (bx_message::info) << "root tree successfully created and branched" << dispatch;
    p_root_tree->SetBranchStatus("tags*", 0);
    p_root_tree->SetBranchStatus("m4s*", 0);
    if (!opts.laben.raw) p_root_tree->SetBranchStatus("laben.decoded_hits.raw_index", 0);
  }
  else
    get_message (bx_message::info) << "root tree disabled" << dispatch; 
}

bx_echidna_event* bx_writer::doit (bx_echidna_event *ev) {
  if (check_parameter ("write_tree") && !get_parameter ("write_tree").get_bool ())
    return ev;

  // We cannot use new/delete for BxEvent obj (see comment in BxEvent.hh)
  *p_root_event = *ev;

  bool mc_disabled = false;
  if (!mc_disabled && ev->get_mctruth().is_data()) { 
    p_root_tree->SetBranchStatus("mctruth*", 0);
    mc_disabled = true;
  }

  if (p_root_tree->Fill () <= 0) get_message (bx_message::critic) << "unable to fill event " << ev->get_event_number() << dispatch;

  if(!(ev->get_event_number()%1000))
    get_message(bx_message::info) << "filling ev: " << ev->get_event_number() << dispatch;  

  u4_written_events++;
  return ev;
}

void bx_writer::end () {
  if (p_root_file) {
    // write tree
    if (check_parameter ("write_tree") && get_parameter ("write_tree").get_bool ()) {
      if (p_root_tree) p_root_tree->Write ();
      if (p_root_event) delete p_root_event;
      if (p_root_tree) delete p_root_tree;    
    }

    // write barn
    if (check_parameter ("write_barn") && get_parameter ("write_barn").get_bool ()) 
      barn_interface::get()->write(p_root_file);
    // close file
    p_root_file->Close ();
    delete p_root_file;
    get_message (bx_message::info) << "Root file closed, " << u4_written_events << " events written" << dispatch;
  }
}

// helper method to retrieve user parameters and fill opt 
void bx_writer::m_parse_options(bx_write_opts &opt) {
  opt.laben.raw       = check_parameter ("write_laben_raw")       ? get_parameter ("write_laben_raw")      .get_bool () : false;
  opt.laben.decoded   = check_parameter ("write_laben_decoded")   ? get_parameter ("write_laben_decoded")  .get_bool () : false;
  opt.laben.clustered = check_parameter ("write_laben_clustered") ? get_parameter ("write_laben_clustered").get_int  () : false;
  opt.laben.rec       = check_parameter ("write_laben_rec")       ? get_parameter ("write_laben_rec")      .get_int  () : false;
  opt.muon.raw        = check_parameter ("write_muon_raw")        ? get_parameter ("write_muon_raw")       .get_bool () : false;
  opt.muon.decoded    = check_parameter ("write_muon_decoded")    ? get_parameter ("write_muon_decoded")   .get_bool () : false;
  opt.muon.clustered  = check_parameter ("write_muon_clustered")  ? get_parameter ("write_muon_clustered") .get_bool () : false;
  opt.mctruth         = check_parameter ("write_mctruth")         ? get_parameter ("write_mctruth")        .get_int  () : false;
}

/*
 * $Log: bx_writer.cc,v $
 * Revision 1.46  2015/04/23 22:38:17  misiaszek
 * SetBranch for non-existing neutron variable removed
 *
 * Revision 1.45  2011/02/18 17:10:05  ddangelo
 * major code cleanup: removed fadc throughout the program
 *
 * Revision 1.44  2010-03-08 20:40:04  razeto
 * Disable m4 branch for writing
 *
 * Revision 1.43  2009-10-05 15:35:30  ddangelo
 * some more disabling. Forgot to commit before.
 *
 * Revision 1.42  2009-08-03 15:39:33  ddangelo
 * trying to debug
 *
 * Revision 1.41  2009-07-30 16:54:51  ddangelo
 * debugging the disabling of unused branches
 *
 * Revision 1.40  2009-07-17 17:06:07  ddangelo
 * disabled fadc
 * disabled mctruth if real data
 *
 * Revision 1.39  2008-11-06 14:46:30  razeto
 * Check filling of tree for errors
 *
 * Revision 1.38  2008-10-19 10:47:59  razeto
 * Remove output rootfile on SIGTERM
 *
 * Revision 1.37  2007-05-09 14:18:27  ddangelo
 * debugging
 *
 * Revision 1.36  2007-05-07 13:40:50  ddangelo
 * applying patch to flag TObjects with cycle numbers
 *
 * Revision 1.35  2007-03-28 17:41:52  ddangelo
 * updated param readout
 *
 * Revision 1.34  2007-03-22 16:11:13  ddangelo
 * added one parameter
 *
 * Revision 1.33  2007/02/04 17:17:09  ddangelo
 * added the possibility to specify output dir
 *
 * Revision 1.32  2006-12-14 16:10:26  ddangelo
 * removed aliases
 *
 * Revision 1.31  2006/12/14 14:56:04  ddangelo
 * max root file size increase from 1.8GB to 128GB.
 * This should limit the occurrence of multiple run production.
 *
 * Root files named after configuration.
 *
 * Revision 1.30  2006/11/24 14:17:53  ddangelo
 * added a log msg with btb threshold
 *
 * Revision 1.29  2006/09/05 16:35:55  razeto
 * Added some shortcuts asked by Marco
 *
 * Revision 1.28  2006-09-05 13:14:10  ddangelo
 * minor things
 *
 * Revision 1.27  2006/08/21 11:25:33  razeto
 * Updated to new barn_interface + count written events
 *
 * Revision 1.26  2005/07/13 14:10:04  ddangelo
 * remove gloabal event
 *
 * Revision 1.25  2004/12/22 17:05:23  ddangelo
 * minor improvements
 *
 * Revision 1.24  2004/12/01 15:12:36  ddangelo
 * added a parameter handling for fadc root file
 *
 * Revision 1.23  2004/11/26 15:25:11  razeto
 * Thanks to Davide who so kindly underlined a syntactical error, I fixed the "Maintainer" word
 *
 * Revision 1.22  2004/11/26 14:06:23  razeto
 * Added Mantainer field
 *
 * Revision 1.21  2004/09/22 15:02:22  ddangelo
 * class name moved from bx_event_writer to bx_writer to match file name
 *
 * Revision 1.20  2004/09/22 14:16:51  ddangelo
 * root barn output may be toggled (default == true)
 *
 * Revision 1.19  2004/09/22 13:58:59  ddangelo
 * updated bx_reco event into bx_echidna_event
 *
 * Revision 1.18  2004/09/22 11:29:58  ddangelo
 * added require_event_stage in module's constructor
 *
 * Revision 1.17  2004/07/13 14:52:11  ddangelo
 * added a parameter for mctruth
 *
 * Revision 1.16  2004/06/07 15:01:00  ddangelo
 * debugging
 *
 * Revision 1.15  2004/06/07 12:57:23  ddangelo
 * fixed some dependencies
 *
 * Revision 1.14  2004/06/03 14:59:36  ddangelo
 * new/delete on BxEvent replaced with operator=().
 * This should solve the problem of TTree::Fill() caching the addresses of TClonesArray.
 * BxEvent still in tmp state.
 *
 * Revision 1.13  2004/05/31 22:04:07  ddangelo
 * added support for automatic file names
 *
 * Revision 1.12  2004/05/31 11:20:42  ddangelo
 * bug tmp commented out.
 * call to barn_interface::write() reintroduced
 *
 * Revision 1.11  2004/05/30 11:58:14  ddangelo
 * Redisign to use new Root file classes.
 * Filler visitor removed.
 * User control over TTree::Branch() parameters introduced.
 * User parameter control over hit lists writing introduced.
 *
 * Revision 1.9  2004/04/18 09:15:57  razeto
 * Fixed indentation
 *
 * Revision 1.8  2004/04/16 15:02:22  pallas
 * Start developing of root event structure
 * Not defined yet, but preprared infrastructure
 *
 * Revision 1.7  2004/04/06 12:42:17  razeto
 * Added module role to base_module, and the code to handle everywhere. Some other minor fixes
 *
 * Revision 1.6  2004/04/03 09:20:35  razeto
 * Added messenger
 *
 * Revision 1.5  2004/03/21 18:59:41  razeto
 * Some cosmetic changes
 *
 * Revision 1.4  2004/03/21 18:53:01  razeto
 * Some cosmetic changes
 *
 * Revision 1.3  2004/03/20 18:59:26  pallas
 * Change counters
 *
 * Revision 1.2  2004/03/20 18:55:02  pallas
 * Debugging framework
 *
 * Revision 1.1  2004/03/20 17:39:45  pallas
 * First release
 *
 * Revision 1.1  2004/03/20 14:16:47  razeto
 * Added sources
 *
 */
